# Book Service

## Directory Structure
```
book-service/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── library/
│   │   │           └── bookservice/
│   │   │               ├── BookServiceApplication.java
│   │   │               ├── config/
│   │   │               │   ├── KafkaConfig.java
│   │   │               │   └── ElasticsearchConfig.java
│   │   │               ├── controller/
│   │   │               │   └── BookController.java
│   │   │               ├── dto/
│   │   │               │   ├── BookDto.java
│   │   │               │   ├── BookSearchDto.java
│   │   │               │   └── BookEventDto.java
│   │   │               ├── entity/
│   │   │               │   └── Book.java
│   │   │               ├── repository/
│   │   │               │   ├── BookRepository.java
│   │   │               │   └── BookSearchRepository.java
│   │   │               ├── service/
│   │   │               │   ├── BookService.java
│   │   │               │   ├── BookSearchService.java
│   │   │               │   └── BookEventService.java
│   │   │               ├── mapper/
│   │   │               │   └── BookMapper.java
│   │   │               └── exception/
│   │   │                   ├── BookNotFoundException.java
│   │   │                   └── GlobalExceptionHandler.java
│   │   └── resources/
│   │       ├── application.yml
│   │       └── data.sql
│   └── test/
│       └── java/
│           └── com/
│               └── library/
│                   └── bookservice/
│                       ├── BookServiceApplicationTests.java
│                       ├── controller/
│                       │   └── BookControllerTest.java
│                       └── service/
│                           └── BookServiceTest.java
├── Dockerfile
└── pom.xml
```

## pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.library</groupId>
    <artifactId>book-service</artifactId>
    <version>1.0.0</version>
    <name>book-service</name>
    <description>Book Management Service</description>

    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2023.0.0</spring-cloud.version>
        <elasticsearch.version>8.11.0</elasticsearch.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-elasticsearch</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>1.5.5.Final</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>1.5.5.Final</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>elasticsearch</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

## src/main/java/com/library/bookservice/BookServiceApplication.java
```java
package com.library.bookservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.data.elasticsearch.repository.config.EnableElasticsearchRepositories;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.kafka.annotation.EnableKafka;

@SpringBootApplication
@EnableDiscoveryClient
@EnableJpaRepositories(basePackages = "com.library.bookservice.repository")
@EnableElasticsearchRepositories(basePackages = "com.library.bookservice.repository")
@EnableKafka
public class BookServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(BookServiceApplication.class, args);
    }
}
```

## src/main/java/com/library/bookservice/config/KafkaConfig.java
```java
package com.library.bookservice.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {
    
    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;
    
    @Bean
    public ProducerFactory<String, String> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        
        // Producer reliability settings
        configProps.put(ProducerConfig.ACKS_CONFIG, "all"); // Wait for all replicas
        configProps.put(ProducerConfig.RETRIES_CONFIG, 3);
        configProps.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, 1000);
        configProps.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true); // Exactly once semantics
        
        // Performance settings
        configProps.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384);
        configProps.put(ProducerConfig.LINGER_MS_CONFIG, 10);
        configProps.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432);
        
        return new DefaultKafkaProducerFactory<>(configProps);
    }
    
    @Bean
    public KafkaTemplate<String, String> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}
```

## src/main/java/com/library/bookservice/config/ElasticsearchConfig.java
```java
package com.library.bookservice.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.elasticsearch.client.ClientConfiguration;
import org.springframework.data.elasticsearch.client.elc.ElasticsearchConfiguration;

@Configuration
public class ElasticsearchConfig extends ElasticsearchConfiguration {
    
    @Value("${spring.elasticsearch.uris}")
    private String elasticsearchUrl;
    
    @Override
    public ClientConfiguration clientConfiguration() {
        return ClientConfiguration.builder()
            .connectedTo(elasticsearchUrl.replace("http://", ""))
            .build();
    }
}
```

## src/main/java/com/library/bookservice/exception/BookNotFoundException.java
```java
package com.library.bookservice.exception;

public class BookNotFoundException extends RuntimeException {
    public BookNotFoundException(String message) {
        super(message);
    }
}
```

## src/main/java/com/library/bookservice/exception/GlobalExceptionHandler.java
```java
package com.library.bookservice.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.Instant;

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    private

## src/main/java/com/library/bookservice/entity/Book.java
```java
package com.library.bookservice.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import org.springframework.data.annotation.Id;
import org.springframework.data.elasticsearch.annotations.Document;
import org.springframework.data.elasticsearch.annotations.Field;
import org.springframework.data.elasticsearch.annotations.FieldType;

import java.time.LocalDateTime;

@Entity
@Table(name = "books")
@Document(indexName = "books")
public class Book {
    
    @jakarta.persistence.Id
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Title is required")
    @Column(nullable = false)
    @Field(type = FieldType.Text, analyzer = "standard")
    private String title;

    @NotBlank(message = "Author is required")
    @Column(nullable = false)
    @Field(type = FieldType.Text, analyzer = "standard")
    private String author;

    @NotBlank(message = "ISBN is required")
    @Column(nullable = false, unique = true)
    @Field(type = FieldType.Keyword)
    private String isbn;

    @Field(type = FieldType.Text)
    private String description;

    @NotBlank(message = "Genre is required")
    @Column(nullable = false)
    @Field(type = FieldType.Keyword)
    private String genre;

    @NotNull(message = "Publication year is required")
    @Column(nullable = false)
    @Field(type = FieldType.Integer)
    private Integer publicationYear;

    @NotNull(message = "Total copies is required")
    @Column(nullable = false)
    @Field(type = FieldType.Integer)
    private Integer totalCopies;

    @NotNull(message = "Available copies is required")
    @Column(nullable = false)
    @Field(type = FieldType.Integer)
    private Integer availableCopies;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Field(type = FieldType.Keyword)
    private BookStatus status = BookStatus.AVAILABLE;

    @Column(name = "created_at", nullable = false, updatable = false)
    @Field(type = FieldType.Date)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @Field(type = FieldType.Date)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Constructors
    public Book() {}

    public Book(String title, String author, String isbn, String description, 
                String genre, Integer publicationYear, Integer totalCopies) {
        this.title = title;
        this.author = author;
        this.isbn = isbn;
        this.description = description;
        this.genre = genre;
        this.publicationYear = publicationYear;
        this.totalCopies = totalCopies;
        this.availableCopies = totalCopies;
    }

    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getAuthor() { return author; }
    public void setAuthor(String author) { this.author = author; }

    public String getIsbn() { return isbn; }
    public void setIsbn(String isbn) { this.isbn = isbn; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public String getGenre() { return genre; }
    public void setGenre(String genre) { this.genre = genre; }

    public Integer getPublicationYear() { return publicationYear; }
    public void setPublicationYear(Integer publicationYear) { this.publicationYear = publicationYear; }

    public Integer getTotalCopies() { return totalCopies; }
    public void setTotalCopies(Integer totalCopies) { this.totalCopies = totalCopies; }

    public Integer getAvailableCopies() { return availableCopies; }
    public void setAvailableCopies(Integer availableCopies) { 
        this.availableCopies = availableCopies;
        updateStatus();
    }

    public BookStatus getStatus() { return status; }
    public void setStatus(BookStatus status) { this.status = status; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }

    // Business logic methods
    public void borrowCopy() {
        if (availableCopies > 0) {
            availableCopies--;
            updateStatus();
        } else {
            throw new IllegalStateException("No copies available for borrowing");
        }
    }

    public void returnCopy() {
        if (availableCopies < totalCopies) {
            availableCopies++;
            updateStatus();
        } else {
            throw new IllegalStateException("All copies are already returned");
        }
    }

    private void updateStatus() {
        this.status = availableCopies > 0 ? BookStatus.AVAILABLE : BookStatus.UNAVAILABLE;
    }

    public enum BookStatus {
        AVAILABLE, UNAVAILABLE, MAINTENANCE
    }
}
```

## src/main/java/com/library/bookservice/dto/BookDto.java
```java
package com.library.bookservice.dto;

import com.library.bookservice.entity.Book;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Min;

import java.time.LocalDateTime;

public class BookDto {
    
    private Long id;
    
    @NotBlank(message = "Title is required")
    private String title;
    
    @NotBlank(message = "Author is required")
    private String author;
    
    @NotBlank(message = "ISBN is required")
    private String isbn;
    
    private String description;
    
    @NotBlank(message = "Genre is required")
    private String genre;
    
    @NotNull(message = "Publication year is required")
    @Min(value = 1000, message = "Publication year must be valid")
    private Integer publicationYear;
    
    @NotNull(message = "Total copies is required")
    @Min(value = 1, message = "Total copies must be at least 1")
    private Integer totalCopies;
    
    private Integer availableCopies;
    private Book.BookStatus status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // Constructors
    public BookDto() {}

    public BookDto(String title, String author, String isbn, String description,
                   String genre, Integer publicationYear, Integer totalCopies) {
        this.title = title;
        this.author = author;
        this.isbn = isbn;
        this.description = description;
        this.genre = genre;
        this.publicationYear = publicationYear;
        this.totalCopies = totalCopies;
    }

    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getAuthor() { return author; }
    public void setAuthor(String author) { this.author = author; }

    public String getIsbn() { return isbn; }
    public void setIsbn(String isbn) { this.isbn = isbn; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public String getGenre() { return genre; }
    public void setGenre(String genre) { this.genre = genre; }

    public Integer getPublicationYear() { return publicationYear; }
    public void setPublicationYear(Integer publicationYear) { this.publicationYear = publicationYear; }

    public Integer getTotalCopies() { return totalCopies; }
    public void setTotalCopies(Integer totalCopies) { this.totalCopies = totalCopies; }

    public Integer getAvailableCopies() { return availableCopies; }
    public void setAvailableCopies(Integer availableCopies) { this.availableCopies = availableCopies; }

    public Book.BookStatus getStatus() { return status; }
    public void setStatus(Book.BookStatus status) { this.status = status; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
}
```

## src/main/java/com/library/bookservice/dto/BookSearchDto.java
```java
package com.library.bookservice.dto;

import com.library.bookservice.entity.Book;

public class BookSearchDto {
    private Long id;
    private String title;
    private String author;
    private String isbn;
    private String description;
    private String genre;
    private Integer publicationYear;
    private Integer availableCopies;
    private Book.BookStatus status;
    private Double score; // Elasticsearch relevance score

    // Constructors
    public BookSearchDto() {}

    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getAuthor() { return author; }
    public void setAuthor(String author) { this.author = author; }

    public String getIsbn() { return isbn; }
    public void setIsbn(String isbn) { this.isbn = isbn; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public String getGenre() { return genre; }
    public void setGenre(String genre) { this.genre = genre; }

    public Integer getPublicationYear() { return publicationYear; }
    public void setPublicationYear(Integer publicationYear) { this.publicationYear = publicationYear; }

    public Integer getAvailableCopies() { return availableCopies; }
    public void setAvailableCopies(Integer availableCopies) { this.availableCopies = availableCopies; }

    public Book.BookStatus getStatus() { return status; }
    public void setStatus(Book.BookStatus status) { this.status = status; }

    public Double getScore() { return score; }
    public void setScore(Double score) { this.score = score; }
}
```

## src/main/java/com/library/bookservice/dto/BookEventDto.java
```java
package com.library.bookservice.dto;

import com.library.bookservice.entity.Book;

import java.time.LocalDateTime;

public class BookEventDto {
    private String eventType;
    private Long bookId;
    private String title;
    private String author;
    private String isbn;
    private Book.BookStatus status;
    private Integer availableCopies;
    private LocalDateTime timestamp;
    private String correlationId;

    // Constructors
    public BookEventDto() {}

    public BookEventDto(String eventType, Long bookId, String title, String author, 
                       String isbn, Book.BookStatus status, Integer availableCopies, String correlationId) {
        this.eventType = eventType;
        this.bookId = bookId;
        this.title = title;
        this.author = author;
        this.isbn = isbn;
        this.status = status;
        this.availableCopies = availableCopies;
        this.timestamp = LocalDateTime.now();
        this.correlationId = correlationId;
    }

    // Getters and setters
    public String getEventType() { return eventType; }
    public void setEventType(String eventType) { this.eventType = eventType; }

    public Long getBookId() { return bookId; }
    public void setBookId(Long bookId) { this.bookId = bookId; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getAuthor() { return author; }
    public void setAuthor(String author) { this.author = author; }

    public String getIsbn() { return isbn; }
    public void setIsbn(String isbn) { this.isbn = isbn; }

    public Book.BookStatus getStatus() { return status; }
    public void setStatus(Book.BookStatus status) { this.status = status; }

    public Integer getAvailableCopies() { return availableCopies; }
    public void setAvailableCopies(Integer availableCopies) { this.availableCopies = availableCopies; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getCorrelationId() { return correlationId; }
    public void setCorrelationId(String correlationId) { this.correlationId = correlationId; }
}
```

## src/main/java/com/library/bookservice/repository/BookRepository.java
```java
package com.library.bookservice.repository;

import com.library.bookservice.entity.Book;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface BookRepository extends JpaRepository<Book, Long> {
    
    Optional<Book> findByIsbn(String isbn);
    
    List<Book> findByAuthorIgnoreCase(String author);
    
    List<Book> findByGenreIgnoreCase(String genre);
    
    List<Book> findByStatus(Book.BookStatus status);
    
    @Query("SELECT b FROM Book b WHERE b.availableCopies > 0")
    List<Book> findAvailableBooks();
    
    @Query("SELECT b FROM Book b WHERE " +
           "LOWER(b.title) LIKE LOWER(CONCAT('%', :query, '%')) OR " +
           "LOWER(b.author) LIKE LOWER(CONCAT('%', :query, '%')) OR " +
           "LOWER(b.description) LIKE LOWER(CONCAT('%', :query, '%'))")
    Page<Book> searchBooks(@Param("query") String query, Pageable pageable);
    
    @Query("SELECT COUNT(b) FROM Book b WHERE b.availableCopies > 0")
    long countAvailableBooks();
    
    @Query("SELECT b.genre, COUNT(b) FROM Book b GROUP BY b.genre")
    List<Object[]> countBooksByGenre();
    
    boolean existsByIsbn(String isbn);
}
```

## src/main/java/com/library/bookservice/repository/BookSearchRepository.java
```java
package com.library.bookservice.repository;

import com.library.bookservice.entity.Book;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.elasticsearch.annotations.Query;
import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface BookSearchRepository extends ElasticsearchRepository<Book, Long> {
    
    @Query("{\"bool\": {\"should\": [" +
           "{\"match\": {\"title\": {\"query\": \"?0\", \"boost\": 2}}}," +
           "{\"match\": {\"author\": {\"query\": \"?0\", \"boost\": 1.5}}}," +
           "{\"match\": {\"description\": {\"query\": \"?0\", \"boost\": 1}}}," +
           "{\"match\": {\"genre\": {\"query\": \"?0\", \"boost\": 1}}}" +
           "]}}")
    Page<Book> findByMultiMatch(String query, Pageable pageable);
    
    List<Book> findByAuthor(String author);
    
    List<Book> findByGenre(String genre);
    
    @Query("{\"bool\": {\"must\": [" +
           "{\"range\": {\"publicationYear\": {\"gte\": ?0, \"lte\": ?1}}}" +
           "]}}")
    List<Book> findByPublicationYearBetween(Integer startYear, Integer endYear);
    
    @Query("{\"bool\": {\"must\": [" +
           "{\"term\": {\"status\": \"AVAILABLE\"}}," +
           "{\"range\": {\"availableCopies\": {\"gt\": 0}}}" +
           "]}}")
    List<Book> findAvailableBooks();
}
```

## src/main/java/com/library/bookservice/service/BookService.java
```java
package com.library.bookservice.service;

import com.library.bookservice.dto.BookDto;
import com.library.bookservice.entity.Book;
import com.library.bookservice.exception.BookNotFoundException;
import com.library.bookservice.mapper.BookMapper;
import com.library.bookservice.repository.BookRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;

@Service
@Transactional
public class BookService {
    
    private static final Logger logger = LoggerFactory.getLogger(BookService.class);
    
    private final BookRepository bookRepository;
    private final BookMapper bookMapper;
    private final BookEventService bookEventService;
    private final BookSearchService bookSearchService;
    
    @Autowired
    public BookService(BookRepository bookRepository, BookMapper bookMapper, 
                      BookEventService bookEventService, BookSearchService bookSearchService) {
        this.bookRepository = bookRepository;
        this.bookMapper = bookMapper;
        this.bookEventService = bookEventService;
        this.bookSearchService = bookSearchService;
    }
    
    public BookDto createBook(BookDto bookDto) {
        logger.info("Creating new book with ISBN: {}", bookDto.getIsbn());
        
        if (bookRepository.existsByIsbn(bookDto.getIsbn())) {
            throw new IllegalArgumentException("Book with ISBN " + bookDto.getIsbn() + " already exists");
        }
        
        Book book = bookMapper.toEntity(bookDto);
        book.setAvailableCopies(book.getTotalCopies());
        
        Book savedBook = bookRepository.save(book);
        logger.info("Book created successfully with ID: {}", savedBook.getId());
        
        // Index in Elasticsearch
        bookSearchService.indexBook(savedBook);
        
        // Publish event
        String correlationId = UUID.randomUUID().toString();
        bookEventService.publishBookEvent("BOOK_ADDED", savedBook, correlationId);
        
        return bookMapper.toDto(savedBook);
    }
    
    @Transactional(readOnly = true)
    public BookDto getBookById(Long id) {
        logger.debug("Fetching book with ID: {}", id);
        Book book = bookRepository.findById(id)
            .orElseThrow(() -> new BookNotFoundException("Book not found with ID: " + id));
        return bookMapper.toDto(book);
    }
    
    @Transactional(readOnly = true)
    public BookDto getBookByIsbn(String isbn) {
        logger.debug("Fetching book with ISBN: {}", isbn);
        Book book = bookRepository.findByIsbn(isbn)
            .orElseThrow(() -> new BookNotFoundException("Book not found with ISBN: " + isbn));
        return bookMapper.toDto(book);
    }
    
    @Transactional(readOnly = true)
    public Page<BookDto> getAllBooks(Pageable pageable) {
        logger.debug("Fetching all books with pagination");
        return bookRepository.findAll(pageable).map(bookMapper::toDto);
    }
    
    @Transactional(readOnly = true)
    public List<BookDto> getBooksByAuthor(String author) {
        logger.debug("Fetching books by author: {}", author);
        return bookRepository.findByAuthorIgnoreCase(author)
            .stream()
            .map(bookMapper::toDto)
            .toList();
    }
    
    @Transactional(readOnly = true)
    public List<BookDto> getBooksByGenre(String genre) {
        logger.debug("Fetching books by genre: {}", genre);
        return bookRepository.findByGenreIgnoreCase(genre)
            .stream()
            .map(bookMapper::toDto)
            .toList();
    }
    
    @Transactional(readOnly = true)
    public List<BookDto> getAvailableBooks() {
        logger.debug("Fetching available books");
        return bookRepository.findAvailableBooks()
            .stream()
            .map(bookMapper::toDto)
            .toList();
    }
    
    public BookDto updateBook(Long id, BookDto bookDto) {
        logger.info("Updating book with ID: {}", id);
        
        Book existingBook = bookRepository.findById(id)
            .orElseThrow(() -> new BookNotFoundException("Book not found with ID: " + id));
        
        // Update fields
        existingBook.setTitle(bookDto.getTitle());
        existingBook.setAuthor(bookDto.getAuthor());
        existingBook.setDescription(bookDto.getDescription());
        existingBook.setGenre(bookDto.getGenre());
        existingBook.setPublicationYear(bookDto.getPublicationYear());
        
        // Handle inventory changes
        if (!existingBook.getTotalCopies().equals(bookDto.getTotalCopies())) {
            int difference = bookDto.getTotalCopies() - existingBook.getTotalCopies();
            existingBook.setTotalCopies(bookDto.getTotalCopies());
            existingBook.setAvailableCopies(existingBook.getAvailableCopies() + difference);
        }
        
        Book updatedBook = bookRepository.save(existingBook);
        logger.info("Book updated successfully with ID: {}", updatedBook.getId());
        
        // Update in Elasticsearch
        bookSearchService.indexBook(updatedBook);
        
        // Publish event
        String correlationId = UUID.randomUUID().toString();
        bookEventService.publishBookEvent("BOOK_UPDATED", updatedBook, correlationId);
        
        return bookMapper.toDto(updatedBook);
    }
    
    public void deleteBook(Long id) {
        logger.info("Deleting book with ID: {}", id);
        
        Book book = bookRepository.findById(id)
            .orElseThrow(() -> new BookNotFoundException("Book not found with ID: " + id));
        
        bookRepository.delete(book);
        logger.info("Book deleted successfully with ID: {}", id);
        
        // Remove from Elasticsearch
        bookSearchService.deleteBook(id);
        
        // Publish event
        String correlationId = UUID.randomUUID().toString();
        bookEventService.publishBookEvent("BOOK_DELETED", book, correlationId);
    }
    
    public BookDto borrowBook(Long id) {
        logger.info("Processing borrow request for book ID: {}", id);
        
        Book book = bookRepository.findById(id)
            .orElseThrow(() -> new BookNotFoundException("Book not found with ID: " + id));
        
        book.borrowCopy();
        Book updatedBook = bookRepository.save(book);
        logger.info("Book borrowed successfully. Available copies: {}", updatedBook.getAvailableCopies());
        
        // Update in Elasticsearch
        bookSearchService.indexBook(updatedBook);
        
        // Publish event
        String correlationId = UUID.randomUUID().toString();
        bookEventService.publishBookEvent("BOOK_STATUS_CHANGED", updatedBook, correlationId);
        
        return bookMapper.toDto(updatedBook);
    }
    
    public BookDto returnBook(Long id) {
        logger.info("Processing return request for book ID: {}", id);
        
        Book book = bookRepository.findById(id)
            .orElseThrow(() -> new BookNotFoundException("Book not found with ID: " + id));
        
        book.returnCopy();
        Book updatedBook = bookRepository.save(book);
        logger.info("Book returned successfully. Available copies: {}", updatedBook.getAvailableCopies());
        
        // Update in Elasticsearch
        bookSearchService.indexBook(updatedBook);
        
        // Publish event
        String correlationId = UUID.randomUUID().toString();
        bookEventService.publishBookEvent("BOOK_STATUS_CHANGED", updatedBook, correlationId);
        
        return bookMapper.toDto(updatedBook);
    }
    
    @Transactional(readOnly = true)
    public Page<BookDto> searchBooks(String query, Pageable pageable) {
        logger.debug("Searching books with query: {}", query);
        return bookRepository.searchBooks(query, pageable).map(bookMapper::toDto);
    }
    
    @Transactional(readOnly = true)
    public long getAvailableBooksCount() {
        return bookRepository.countAvailableBooks();
    }
    
    @Transactional(readOnly = true)
    public List<Object[]> getBookStatsByGenre() {
        return bookRepository.countBooksByGenre();
    }
}
```

## src/main/java/com/library/bookservice/service/BookSearchService.java
```java
package com.library.bookservice.service;

import com.library.bookservice.dto.BookSearchDto;
import com.library.bookservice.entity.Book;
import com.library.bookservice.mapper.BookMapper;
import com.library.bookservice.repository.BookSearchRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.elasticsearch.core.ElasticsearchOperations;
import org.springframework.data.elasticsearch.core.SearchHit;
import org.springframework.data.elasticsearch.core.SearchHits;
import org.springframework.data.elasticsearch.core.query.NativeSearchQuery;
import org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

import static org.elasticsearch.index.query.QueryBuilders.*;

@Service
public class BookSearchService {
    
    private static final Logger logger = LoggerFactory.getLogger(BookSearchService.class);
    
    private final BookSearchRepository bookSearchRepository;
    private final ElasticsearchOperations elasticsearchOperations;
    private final BookMapper bookMapper;
    
    @Autowired
    public BookSearchService(BookSearchRepository bookSearchRepository, 
                           ElasticsearchOperations elasticsearchOperations, 
                           BookMapper bookMapper) {
        this.bookSearchRepository = bookSearchRepository;
        this.elasticsearchOperations = elasticsearchOperations;
        this.bookMapper = bookMapper;
    }
    
    public void indexBook(Book book) {
        try {
            logger.debug("Indexing book with ID: {} in Elasticsearch", book.getId());
            bookSearchRepository.save(book);
            logger.debug("Book indexed successfully");
        } catch (Exception e) {
            logger.error("Failed to index book with ID: {}", book.getId(), e);
        }
    }
    
    public void deleteBook(Long bookId) {
        try {
            logger.debug("Deleting book with ID: {} from Elasticsearch", bookId);
            bookSearchRepository.deleteById(bookId);
            logger.debug("Book deleted from index successfully");
        } catch (Exception e) {
            logger.error("Failed to delete book with ID: {} from index", bookId, e);
        }
    }
    
    public List<BookSearchDto> searchBooks(String query) {
        logger.debug("Searching books with query: {}", query);
        
        NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()
            .withQuery(multiMatchQuery(query)
                .field("title", 2.0f)
                .field("author", 1.5f)
                .field("description", 1.0f)
                .field("genre", 1.0f)
                .type(org.elasticsearch.index.query.MultiMatchQueryBuilder.Type.BEST_FIELDS))
            .build();
        
        SearchHits<Book> searchHits = elasticsearchOperations.search(searchQuery, Book.class);
        
        return searchHits.stream()
            .map(hit -> {
                BookSearchDto dto = bookMapper.toSearchDto(hit.getContent());
                dto.setScore(hit.getScore());
                return dto;
            })
            .collect(Collectors.toList());
    }
    
    public Page<BookSearchDto> searchBooksWithPagination(String query, Pageable pageable) {
        logger.debug("Searching books with pagination. Query: {}", query);
        
        Page<Book> books = bookSearchRepository.findByMultiMatch(query, pageable);
        return books.map(bookMapper::toSearchDto);
    }
    
    public List<BookSearchDto> searchByAuthor(String author) {
        logger.debug("Searching books by author: {}", author);
        return bookSearchRepository.findByAuthor(author)
            .stream()
            .map(bookMapper::toSearchDto)
            .collect(Collectors.toList());
    }
    
    public List<BookSearchDto> searchByGenre(String genre) {
        logger.debug("Searching books by genre: {}", genre);
        return bookSearchRepository.findByGenre(genre)
            .stream()
            .map(bookMapper::toSearchDto)
            .collect(Collectors.toList());
    }
    
    public List<BookSearchDto> searchByYearRange(Integer startYear, Integer endYear) {
        logger.debug("Searching books by year range: {} - {}", startYear, endYear);
        return bookSearchRepository.findByPublicationYearBetween(startYear, endYear)
            .stream()
            .map(bookMapper::toSearchDto)
            .collect(Collectors.toList());
    }
    
    public List<BookSearchDto> searchAvailableBooks() {
        logger.debug("Searching available books");
        return bookSearchRepository.findAvailableBooks()
            .stream()
            .map(bookMapper::toSearchDto)
            .collect(Collectors.toList());
    }
    
    public List<BookSearchDto> advancedSearch(String title, String author, String genre, 
                                            Integer yearFrom, Integer yearTo, Boolean availableOnly) {
        logger.debug("Advanced search with filters");
        
        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();
        
        if (title != null && !title.trim().isEmpty()) {
            queryBuilder.withQuery(matchQuery("title", title));
        }
        
        if (author != null && !author.trim().isEmpty()) {
            queryBuilder.withQuery(matchQuery("author", author));
        }
        
        if (genre != null && !genre.trim().isEmpty()) {
            queryBuilder.withQuery(termQuery("genre", genre));
        }
        
        if (yearFrom != null && yearTo != null) {
            queryBuilder.withQuery(rangeQuery("publicationYear").gte(yearFrom).lte(yearTo));
        }
        
        if (availableOnly != null && availableOnly) {
            queryBuilder.withQuery(boolQuery()
                .must(termQuery("status", "AVAILABLE"))
                .must(rangeQuery("availableCopies").gt(0)));
        }
        
        SearchHits<Book> searchHits = elasticsearchOperations.search(queryBuilder.build(), Book.class);
        
        return searchHits.stream()
            .map(hit -> {
                BookSearchDto dto = bookMapper.toSearchDto(hit.getContent());
                dto.setScore(hit.getScore());
                return dto;
            })
            .collect(Collectors.toList());
    }
}
```

## src/main/java/com/library/bookservice/service/BookEventService.java
```java
package com.library.bookservice.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.library.bookservice.dto.BookEventDto;
import com.library.bookservice.entity.Book;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.stereotype.Service;

import java.util.concurrent.CompletableFuture;

@Service
public class BookEventService {
    
    private static final Logger logger = LoggerFactory.getLogger(BookEventService.class);
    private static final String BOOK_EVENTS_TOPIC = "book-events";
    
    private final KafkaTemplate<String, String> kafkaTemplate;
    private final ObjectMapper objectMapper;
    
    @Autowired
    public BookEventService(KafkaTemplate<String, String> kafkaTemplate, ObjectMapper objectMapper) {
        this.kafkaTemplate = kafkaTemplate;
        this.objectMapper = objectMapper;
    }
    
    public void publishBookEvent(String eventType, Book book, String correlationId) {
        try {
            // Set correlation ID in MDC for logging
            MDC.put("correlationId", correlationId);
            
            BookEventDto eventDto = new BookEventDto(
                eventType,
                book.getId(),
                book.getTitle(),
                book.getAuthor(),
                book.getIsbn(),
                book.getStatus(),
                book.getAvailableCopies(),
                correlationId
            );
            
            String eventJson = objectMapper.writeValueAsString(eventDto);
            
            logger.info("Publishing book event: {} for book ID: {}", eventType, book.getId());
            
            // Use book ID as partition key for ordering
            CompletableFuture<SendResult<String, String>> future = kafkaTemplate.send(
                BOOK_EVENTS_TOPIC, 
                book.getId().toString(), 
                eventJson
            );
            
            future.whenComplete((result, ex) -> {
                if (ex != null) {
                    logger.error("Failed to publish book event: {} for book ID: {}", 
                               eventType, book.getId(), ex);
                } else {
                    logger.info("Book event published successfully: {} for book ID: {} to partition: {}", 
                               eventType, book.getId(), result.getRecordMetadata().partition());
                }
            });
            
        } catch (JsonProcessingException e) {
            logger.error("Failed to serialize book event: {} for book ID: {}", 
                        eventType, book.getId(), e);
        } finally {
            MDC.clear();
        }
    }
}
```

## src/main/java/com/library/bookservice/mapper/BookMapper.java
```java
package com.library.bookservice.mapper;

import com.library.bookservice.dto.BookDto;
import com.library.bookservice.dto.BookSearchDto;
import com.library.bookservice.entity.Book;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface BookMapper {
    
    BookDto toDto(Book book);
    
    Book toEntity(BookDto bookDto);
    
    BookSearchDto toSearchDto(Book book);
    
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateEntity(@MappingTarget Book book, BookDto bookDto);
}
```

## src/main/java/com/library/bookservice/controller/BookController.java
```java
package com.library.bookservice.controller;

import com.library.bookservice.dto.BookDto;
import com.library.bookservice.dto.BookSearchDto;
import com.library.bookservice.service.BookService;
import com.library.bookservice.service.BookSearchService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/books")
@Tag(name = "Book Management", description = "APIs for managing books in the library")
public class BookController {
    
    private static final Logger logger = LoggerFactory.getLogger(BookController.class);
    
    private final BookService bookService;
    private final BookSearchService bookSearchService;
    
    @Autowired
    public BookController(BookService bookService, BookSearchService bookSearchService) {
        this.bookService = bookService;
        this.bookSearchService = bookSearchService;
    }
    
    @PostMapping
    @Operation(summary = "Create a new book", description = "Add a new book to the library catalog")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "201", description = "Book created successfully"),
        @ApiResponse(responseCode = "400", description = "Invalid input data"),
        @ApiResponse(responseCode = "409", description = "Book with ISBN already exists")
    })
    public ResponseEntity<BookDto> createBook(@Valid @RequestBody BookDto bookDto) {
        String correlationId = UUID.randomUUID().toString();
        MDC.put("correlationId", correlationId);
        
        logger.info("Creating book with title: {}", bookDto.getTitle());
        BookDto createdBook = bookService.createBook(bookDto);
        logger.info("Book created successfully with ID: {}", createdBook.getId());
        
        MDC.clear();
        return new ResponseEntity<>(createdBook, HttpStatus.CREATED);
    }
    
    @GetMapping("/{id}")
    @Operation(summary = "Get book by ID", description = "Retrieve a book by its unique identifier")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Book found"),
        @ApiResponse(responseCode = "404", description = "Book not found")
    })
    public ResponseEntity<BookDto> getBookById(@PathVariable Long id) {
        logger.debug("Fetching book with ID: {}", id);
        BookDto book = bookService.getBookById(id);
        return ResponseEntity.ok(book);
    }
    
    @GetMapping("/isbn/{isbn}")
    @Operation(summary = "Get book by ISBN", description = "Retrieve a book by its ISBN")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Book found"),
        @ApiResponse(responseCode = "404", description = "Book not found")
    })
    public ResponseEntity<BookDto> getBookByIsbn(@PathVariable String isbn) {
        logger.debug("Fetching book with ISBN: {}", isbn);
        BookDto book = bookService.getBookByIsbn(isbn);
        return ResponseEntity.ok(book);
    }
    
    @GetMapping
    @Operation(summary = "Get all books", description = "Retrieve all books with pagination")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Books retrieved successfully")
    })
    public ResponseEntity<Page<BookDto>> getAllBooks(
        @PageableDefault(size = 20) Pageable pageable) {
        logger.debug("Fetching all books with pagination");
        Page<BookDto> books = bookService.getAllBooks(pageable);
        return ResponseEntity.ok(books);
    }
    
    @GetMapping("/author/{author}")
    @Operation(summary = "Get books by author", description = "Retrieve books by a specific author")
    public ResponseEntity<List<BookDto>> getBooksByAuthor(@PathVariable String author) {
        logger.debug("Fetching books by author: {}", author);
        List<BookDto> books = bookService.getBooksByAuthor(author);
        return ResponseEntity.ok(books);
    }
    
    @GetMapping("/genre/{genre}")
    @Operation(summary = "Get books by genre", description = "Retrieve books by a specific genre")
    public ResponseEntity<List<BookDto>> getBooksByGenre(@PathVariable String genre) {
        logger.debug("Fetching books by genre: {}", genre);
        List<BookDto> books = bookService.getBooksByGenre(genre);
        return ResponseEntity.ok(books);
    }
    
    @GetMapping("/available")
    @Operation(summary = "Get available books", description = "Retrieve all books that are currently available for borrowing")
    public ResponseEntity<List<BookDto>> getAvailableBooks() {
        logger.debug("Fetching available books");
        List<BookDto> books = bookService.getAvailableBooks();
        return ResponseEntity.ok(books);
    }
    
    @PutMapping("/{id}")
    @Operation(summary = "Update book", description = "Update an existing book")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Book updated successfully"),
        @ApiResponse(responseCode = "404", description = "Book not found"),
        @ApiResponse(responseCode = "400", description = "Invalid input data")
    })
    public ResponseEntity<BookDto> updateBook(@PathVariable Long id, @Valid @RequestBody BookDto bookDto) {
        String correlationId = UUID.randomUUID().toString();
        MDC.put("correlationId", correlationId);
        
        logger.info("Updating book with ID: {}", id);
        BookDto updatedBook = bookService.updateBook(id, bookDto);
        logger.info("Book updated successfully with ID: {}", id);
        
        MDC.clear();
        return ResponseEntity.ok(updatedBook);
    }
    
    @DeleteMapping("/{id}")
    @Operation(summary = "Delete book", description = "Delete a book from the catalog")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "204", description = "Book deleted successfully"),
        @ApiResponse(responseCode = "404", description = "Book not found")
    })
    public ResponseEntity<Void> deleteBook(@PathVariable Long id) {
        String correlationId = UUID.randomUUID().toString();
        MDC.put("correlationId", correlationId);
        
        logger.info("Deleting book with ID: {}", id);
        bookService.deleteBook(id);
        logger.info("Book deleted successfully with ID: {}", id);
        
        MDC.clear();
        return ResponseEntity.noContent().build();
    }
    
    @PostMapping("/{id}/borrow")
    @Operation(summary = "Borrow a book", description = "Mark a book as borrowed (reduce available copies)")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Book borrowed successfully"),
        @ApiResponse(responseCode = "404", description = "Book not found"),
        @ApiResponse(responseCode = "400", description = "No copies available")
    })
    public ResponseEntity<BookDto> borrowBook(@PathVariable Long id) {
        String correlationId = UUID.randomUUID().toString();
        MDC.put("correlationId", correlationId);
        
        logger.info("Processing borrow request for book ID: {}", id);
        BookDto book = bookService.borrowBook(id);
        logger.info("Book borrowed successfully. Book ID: {}", id);
        
        MDC.clear();
        return ResponseEntity.ok(book);
    }
    
    @PostMapping("/{id}/return")
    @Operation(summary = "Return a book", description = "Mark a book as returned (increase available copies)")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Book returned successfully"),
        @ApiResponse(responseCode = "404", description = "Book not found"),
        @ApiResponse(responseCode = "400", description = "All copies are already returned")
    })
    public ResponseEntity<BookDto> returnBook(@PathVariable Long id) {
        String correlationId = UUID.randomUUID().toString();
        MDC.put("correlationId", correlationId);
        
        logger.info("Processing return request for book ID: {}", id);
        BookDto book = bookService.returnBook(id);
        logger.info("Book returned successfully. Book ID: {}", id);
        
        MDC.clear();
        return ResponseEntity.ok(book);
    }
    
    @GetMapping("/search")
    @Operation(summary = "Search books", description = "Search books using database query")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Search completed successfully")
    })
    public ResponseEntity<Page<BookDto>> searchBooks(
        @RequestParam @Parameter(description = "Search query") String query,
        @PageableDefault(size = 20) Pageable pageable) {
        logger.debug("Searching books with query: {}", query);
        Page<BookDto> books = bookService.searchBooks(query, pageable);
        return ResponseEntity.ok(books);
    }
    
    @GetMapping("/search/elasticsearch")
    @Operation(summary = "Search books with Elasticsearch", description = "Advanced search using Elasticsearch")
    public ResponseEntity<List<BookSearchDto>> searchBooksElasticsearch(
        @RequestParam @Parameter(description = "Search query") String query) {
        logger.debug("Elasticsearch search with query: {}", query);
        List<BookSearchDto> books = bookSearchService.searchBooks(query);
        return ResponseEntity.ok(books);
    }
    
    @GetMapping("/search/elasticsearch/paginated")
    @Operation(summary = "Search books with Elasticsearch and pagination")
    public ResponseEntity<Page<BookSearchDto>> searchBooksElasticsearchPaginated(
        @RequestParam @Parameter(description = "Search query") String query,
        @PageableDefault(size = 20) Pageable pageable) {
        logger.debug("Elasticsearch paginated search with query: {}", query);
        Page<BookSearchDto> books = bookSearchService.searchBooksWithPagination(query, pageable);
        return ResponseEntity.ok(books);
    }
    
    @GetMapping("/search/advanced")
    @Operation(summary = "Advanced search", description = "Advanced search with multiple filters")
    public ResponseEntity<List<BookSearchDto>> advancedSearch(
        @RequestParam(required = false) String title,
        @RequestParam(required = false) String author,
        @RequestParam(required = false) String genre,
        @RequestParam(required = false) Integer yearFrom,
        @RequestParam(required = false) Integer yearTo,
        @RequestParam(required = false) Boolean availableOnly) {
        logger.debug("Advanced search with filters");
        List<BookSearchDto> books = bookSearchService.advancedSearch(
            title, author, genre, yearFrom, yearTo, availableOnly);
        return ResponseEntity.ok(books);
    }
    
    @GetMapping("/stats/available-count")
    @Operation(summary = "Get available books count", description = "Get the count of available books")
    public ResponseEntity<Long> getAvailableBooksCount() {
        long count = bookService.getAvailableBooksCount();
        return ResponseEntity.ok(count);
    }
    
    @GetMapping("/stats/by-genre")
    @Operation(summary = "Get books statistics by genre", description = "Get book count grouped by genre")
    public ResponseEntity<List<Object[]>> getBookStatsByGenre() {
        List<Object[]> stats = bookService.getBookStatsByGenre();
        return ResponseEntity.ok(stats);
    }
}